%% ===================================================================
%% Project: Erlang WELL RNG 44497ac
%% File: well44497a.erl
%% Description: RNG (WELL44497a)
%% Author: CGSMCMLXXV <cgsmcmlxxv@gmail.com>
%% Copyright: 2011 CGSMCMLXXV (for Erlang implementation)
%% License: This RNG can be used freely for personal, academic,
%%          or non-commercial purposes. For commercial purposes,
%%          please contact P. L'Ecuyer at: lecuyer@iro.UMontreal.ca
%% ===================================================================


-module(well44497a).

-define(W,32).
-define(R,1391).
-define(P,15).
-define(MASKU,16#ffffffff bsr (?W-?P)).
-define(MASKL,bnot ?MASKU).

-define(M1,23).
-define(M2,481).
-define(M3,229).

%% To obtain the WELL44497b, set TEMPERING to true
-define(TEMPERING,false).

-define(TEMPERB,16#93dd1400).
-define(TEMPERC,16#fa118000).

-define(MAT0POS,fun(T,V) -> V bxor (V bsr T) end).
-define(MAT0NEG,fun(T,V) -> V bxor (V bsr (-T)) end).
-define(MAT1,fun(V)-> V end).
-define(MAT2,fun(A,V)-> case V band 1 of 1 -> (V bsr 1) bxor A; _ELSE -> V bsr 1 end end).
-define(MAT3POS,fun(T,V)-> V bsr T end).
-define(MAT3NEG,fun(T,V)-> V bsl (-T) end).
-define(MAT4POS,fun(T,B,V) -> V bxor ((V bsr T) band B) end).
-define(MAT4NEG,fun(T,B,V) -> V bxor ((V bsl (-T)) band B) end).
-define(MAT5,fun(R,A,DS,DT,V)-> case V band DT of 1 -> (((V bsl R) bxor (V bsr (?W-R))) band DS) bxor A; _ELSE -> ((V bsl R) bxor (V bsr (?W-R))) band DS end end).
-define(MAT7,fun(V)-> 0 end).

%% accessors
-define(V0,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX,STATE) end).
-define(VM1Over,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M1-?R,STATE) end).
-define(VM1,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M1,STATE) end).
-define(VM2Over,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M2-?R,STATE) end).
-define(VM2,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M2,STATE) end).
-define(VM3Over,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M3-?R,STATE) end).
-define(VM3,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?M3,STATE) end).
-define(Vrm1,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX-1,STATE) end).
-define(Vrm1Under,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?R-1,STATE) end).
-define(Vrm2,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX-2,STATE) end).
-define(Vrm2Under,fun({STATE,STATE_INDEX})-> lists:nth(STATE_INDEX+?R-2,STATE) end).

%% modifiers
-define(V0M,fun({STATE,STATE_INDEX},Index,Value)-> STATE1 = lists:sublist(STATE,1,STATE_INDEX-1+Index)++[Value]++lists:sublist(STATE,STATE_INDEX+1,?R), {STATE1,STATE_INDEX} end).
-define(NewV0,fun(SL,V1)-> ?V0M(SL,-1,V1) end).
-define(NewV0Under,fun(SL,V1)-> ?V0M(SL,?R-1,V1) end).
-define(NewV1,fun(SL,V1)-> ?V0M(SL,0,V1) end).
-define(NewVrm1,fun(SL,V1)-> ?V0M(SL,-2,V1) end).
-define(NewVrm1Under,fun(SL,V1)-> ?V0M(SL,?R-2,V1) end).

-define(FACT,16#ffffffff).

-define(RETURN,fun(SLL)-> case ?TEMPERING of true -> Y1 = ?V0(SLL) bxor (?V0(SLL) bsl 7) band ?TEMPERB, Y  = Y1 bxor (Y1 bsl 15) band ?TEMPERC, {SLL,trunc(Y rem ?FACT)}; false -> {SLL,trunc(?V0(SLL) rem ?FACT)} end end).

-export([init/1,next/1]).

%% initialization:
%%    - by a number (using internal RAND);
init(SEED) when is_integer(SEED) -> next({create_list(SEED),1});
%%    - by a list generated by another RNG (must be of 1932 values).
init(SEED) when is_list(SEED) -> next({SEED,1}).

%% computing generated state and value as {STATE,VALUE} with
%%    - STATE = {K: list of integers, N: next seed index}
%%    - VALUE: computed value for the given state STATE
next({K,N}) when  N >  ?R-?M1                   -> case_3({K,N});
next({K,N}) when (N =< ?R-?M1) and (N > ?R-?M3) -> case_4({K,N});
next({K,N}) when (N =< ?R-?M3) and (N > ?R-?M2) -> case_5({K,N});
next({K,N}) when (N =< ?R-?M2) and (N > 2     ) -> case_6({K,N});
next({K,N}) when  N == 2                        -> case_2({K,N});
next({K,N}) when  N == 1                        -> case_1({K,N}).

case_1(S) ->
    Z0 = (?Vrm1Under(S) band ?MASKL) bor (?Vrm2Under(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1(S)),
    Z2 = ?MAT0NEG(-10,?VM2(S)) bxor ?MAT3NEG(-26,?VM3(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0UnderS,_} = ?NewV0Under(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0UnderS,?R-1},
    {S2,_} = case_3(S1),
    ?RETURN(S2).

case_2(S) ->
    Z0 = (?Vrm1(S) band ?MASKL) bor (?Vrm2Under(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1(S)),
    Z2 = ?MAT0NEG(-10,?VM2(S)) bxor ?MAT3NEG(-26,?VM3(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0UnderS,_} = ?NewV0Under(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0UnderS,1},
    {S2,_} = case_1(S1),
    ?RETURN(S2).

case_3(S) ->
    Z0 = (?Vrm1(S) band ?MASKL) bor (?Vrm2(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1Over(S)),
    Z2 = ?MAT0NEG(-10,?VM2Over(S)) bxor ?MAT3NEG(-26,?VM3Over(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0S,NewV0I} = ?NewV0(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0S,NewV0I-1},
    {S2,_} = case (NewV0I-1) < (?R-?M1) of true -> case_4(S1); false -> {S1,0} end,
    ?RETURN(S2).

case_4(S) ->
    Z0 = (?Vrm1(S) band ?MASKL) bor (?Vrm2(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1(S)),
    Z2 = ?MAT0NEG(-10,?VM2Over(S)) bxor ?MAT3NEG(-26,?VM3Over(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0S,NewV0I} = ?NewV0(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0S,NewV0I-1},
    {S2,_} = case NewV0I-1 < ?R-?M3 of true -> case_5(S1); false -> {S1,0} end,
    ?RETURN(S2).

case_5(S) ->
    Z0 = (?Vrm1(S) band ?MASKL) bor (?Vrm2(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1(S)),
    Z2 = ?MAT0NEG(-10,?VM2Over(S)) bxor ?MAT3NEG(-26,?VM3(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0S,NewV0I} = ?NewV0(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0S,NewV0I-1},
    {S2,_} = case NewV0I-1 < ?R-?M2 of true -> case_6(S1); false -> {S1,0} end,
    ?RETURN(S2).

case_6(S) ->
    Z0 = (?Vrm1(S) band ?MASKL) bor (?Vrm2(S) band ?MASKU),
    Z1 = ?MAT0NEG(-24,?V0(S)) bxor ?MAT0POS(30,?VM1(S)),
    Z2 = ?MAT0NEG(-10,?VM2(S)) bxor ?MAT3NEG(-26,?VM3(S)),
    NewV1S = ?NewV1(S,Z1 bxor Z2),
    {NewV0S,NewV0I} = ?NewV0(NewV1S,?MAT1(Z0) bxor ?MAT0POS(20,Z1) bxor ?MAT5(9,16#b729fcec,16#fbffffff,16#00020000,Z2) bxor ?MAT1(?V0(NewV1S))),
    S1 = {NewV0S,NewV0I-1},
    {S2,_} = case NewV0I == 2 of true -> case_2(S1); false -> {S1,0} end,
    ?RETURN(S2).

rand(S) -> (trunc(69069.0*S+1.0) rem ?FACT).%%/4294967296.

%% recommended seed: 62182
create_list(SEED) ->
    Y = fun(Function) -> (fun(Recurse) -> Recurse(Recurse) end)(fun(Recurse) -> fun(X) -> (Function(Recurse(Recurse)))(X) end end) end,
    INIT = fun(Recurse) ->
               fun({N,S}) when not (N > ?R)  -> R = rand(S), [R|Recurse({N+1,R})];
                  ({N,S}) when      N > ?R -> [rand(S)]
               end
           end,
    (Y(INIT))({1,SEED}).

